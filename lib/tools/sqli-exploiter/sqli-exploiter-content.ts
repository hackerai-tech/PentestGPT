import { Message } from "@/types/chat"
import {
  createGKEHeaders,
  getCommandFromAIResponse,
  processAIResponseAndUpdateMessage
} from "../../plugins/chatpluginhandlers"
import {
  SQLIExploiterParams,
  SQLI_ALLOWED_ENUM_TYPES,
  SQLI_ALLOWED_TAMPERS,
  SQLI_ALLOWED_TECHNIQUES,
  SQLI_DEFAULT_PARAMS,
  SQLI_FLAG_MAP,
  SQLI_MAX_INPUT_LENGTH
} from "@/lib/tools/tool-helper/tools-flags"

import { displayHelpGuideForSQLIExploiter } from "@/lib/plugins/plugin-helper/help-guides"
import { transformUserQueryToSQLIExploiterCommand } from "@/lib/plugins/plugin-helper/transform-query-to-command"
import { handlePluginStreamError } from "@/lib/plugins/plugin-helper/plugin-stream"
import {
  createResponseString,
  makeToolRequest,
  processStreamResponse
} from "@/lib/tools/tool-helper/tools-stream"

const parseCommandLine = (input: string): SQLIExploiterParams => {
  if (input.length > SQLI_MAX_INPUT_LENGTH) {
    return { ...SQLI_DEFAULT_PARAMS, error: `ðŸš¨ Input command is too long` }
  }

  const args = input.trim().split(/\s+/).slice(1)
  const params = { ...SQLI_DEFAULT_PARAMS }

  for (let i = 0; i < args.length; i++) {
    const flag = args[i]
    const param = SQLI_FLAG_MAP[flag]

    if (!param) {
      return { ...params, error: `ðŸš¨ Invalid or unrecognized flag: ${flag}` }
    }

    if (param === "lightCrawling") {
      params.lightCrawling = true
      continue
    }

    const value = args[++i]
    if (value === undefined) {
      return { ...params, error: `ðŸš¨ Missing value for flag: ${flag}` }
    }

    try {
      switch (param) {
        case "targetUrl":
          if (!/^https?:\/\//i.test(value)) {
            throw new Error(
              `Invalid URL: ${value}. URL must start with http:// or https://`
            )
          }
          params.targetUrl = value
          break
        case "method":
          if (value !== "GET" && value !== "POST") {
            throw new Error(`Invalid method: ${value}. Must be GET or POST`)
          }
          params.method = value
          break
        case "enumeration":
          const enumTypes = value.split(",").map(type => type.trim())
          const validEnumTypes = enumTypes.filter(type =>
            SQLI_ALLOWED_ENUM_TYPES.includes(type as any)
          )
          if (validEnumTypes.length === 0) {
            throw new Error(
              `Invalid enumeration types. Allowed types are: ${SQLI_ALLOWED_ENUM_TYPES.join(", ")}`
            )
          }
          params.enumeration =
            validEnumTypes as typeof SQLI_DEFAULT_PARAMS.enumeration
          break
        case "testParameters":
          params.testParameters = value.split(",")
          break
        case "level":
        case "risk":
          const numValue = parseInt(value, 10)
          const max = param === "level" ? 5 : 3
          if (isNaN(numValue) || numValue < 1 || numValue > max) {
            throw new Error(
              `Invalid ${param} value: ${value}. Must be between 1 and ${max}`
            )
          }
          params[param] = numValue
          break
        case "httpCode":
          const code = parseInt(value, 10)
          if (isNaN(code) || code < 100 || code >= 600) {
            throw new Error(
              `Invalid HTTP code: ${value}. Must be between 100 and 599`
            )
          }
          params.httpCode = code
          break
        case "tamper":
          if (!SQLI_ALLOWED_TAMPERS.includes(value as any)) {
            throw new Error(
              `Invalid tamper option: ${value}. Allowed options are: ${SQLI_ALLOWED_TAMPERS.join(", ")}`
            )
          }
          params.tamper = value
          break
        case "techniques":
          const techniques = value.toUpperCase().split("")
          const validTechniques = techniques.filter(tech =>
            SQLI_ALLOWED_TECHNIQUES.includes(tech as any)
          )
          if (validTechniques.length === 0) {
            throw new Error(
              `Invalid techniques. Allowed techniques are: ${SQLI_ALLOWED_TECHNIQUES.join(", ")}`
            )
          }
          params.techniques = validTechniques.join("")
          break
        default:
          params[param] = value
      }
    } catch (error: any) {
      return { ...params, error: `ðŸš¨ ${error.message}` }
    }
  }

  if (!params.targetUrl) {
    return { ...params, error: `ðŸš¨ Error: Target URL is required.` }
  }

  return params
}

export async function handleSqliexploiterRequest(
  lastMessage: Message,
  enableSQLIExploiter: boolean,
  OpenRouterStream: any,
  messagesToSend: Message[],
  invokedByToolId: boolean
) {
  if (!enableSQLIExploiter) {
    return new Response("The SQLi Exploiter is disabled.")
  }

  let aiResponse = ""

  const headers = createGKEHeaders()

  const stream = new ReadableStream({
    async start(controller) {
      const sendMessage = (
        data: string,
        addExtraLineBreaks: boolean = false
      ) => {
        const formattedData = addExtraLineBreaks ? `${data}\n\n` : data
        controller.enqueue(new TextEncoder().encode(formattedData))
      }

      if (invokedByToolId) {
        try {
          for await (const chunk of processAIResponseAndUpdateMessage(
            lastMessage,
            transformUserQueryToSQLIExploiterCommand,
            OpenRouterStream,
            messagesToSend
          )) {
            sendMessage(chunk, false)
            aiResponse += chunk
          }

          sendMessage("\n\n")
          lastMessage.content = getCommandFromAIResponse(
            lastMessage,
            aiResponse
          )
        } catch (error) {
          return new Response(`Error processing AI response: ${error}`)
        }
      }

      const parts = lastMessage.content.split(" ")
      if (parts.includes("-h") || parts.includes("-help")) {
        sendMessage(displayHelpGuideForSQLIExploiter(), true)
        controller.close()
        return
      }

      const params = parseCommandLine(lastMessage.content)

      if (params.error) {
        handlePluginStreamError(
          params.error,
          invokedByToolId,
          sendMessage,
          controller
        )
        return
      }

      let sqliExploiterUrl = `${process.env.SECRET_GKE_TOOLS_BASE_URL}/api/chat/tools/sqli-exploiter`
      sendMessage("ðŸš€ Starting the scan. It might take a minute or two.", true)
      const startTime = Date.now()

      try {
        const sqliExploiterResponse = await makeToolRequest(
          sqliExploiterUrl,
          params,
          `${process.env.SECRET_AUTH_TOOLS}`
        )

        const { scanError } = await processStreamResponse(
          sqliExploiterResponse,
          sendMessage
        )

        if (scanError) {
          sendMessage(`ðŸš¨ ${scanError}`, true)
          controller.close()
          return
        }

        const endTime = Date.now()
        const responseString = createResponseString(
          "SQLi Exploiter",
          "",
          "",
          startTime,
          endTime,
          false
        )
        sendMessage(responseString, true)

        controller.close()
      } catch (error) {
        let errorMessage =
          "ðŸš¨ There was a problem during the scan. Please try again."
        if (error instanceof Error) {
          errorMessage = `ðŸš¨ Error: ${error.message}`
        }
        sendMessage(errorMessage, true)
        controller.close()
        return new Response(errorMessage)
      }
    }
  })

  return new Response(stream, { headers })
}
